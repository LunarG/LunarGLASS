
Top IR:
; ModuleID = 'Glslang'

@iout = global <4 x i32> zeroinitializer
@uout = global <4 x i32> zeroinitializer
@fout = global <4 x float> zeroinitializer
@u2 = global <2 x i32> zeroinitializer
@u1 = global i32 0
@u4 = global <4 x i32> zeroinitializer
@i4 = global <4 x i32> zeroinitializer
@i1 = global i32 0
@u3 = global <3 x i32> zeroinitializer
@i3 = global <3 x i32> zeroinitializer
@i2 = global <2 x i32> zeroinitializer
@v3 = global <3 x float> zeroinitializer
@v1 = global float 0.000000e+00
@v2 = global <2 x float> zeroinitializer
@v4 = global <4 x float> zeroinitializer
@gl_VertexID = global i32 0
@gl_InstanceID = global i32 0

define fastcc void @main() {
entry:
  %i1out = alloca i32
  %i3out = alloca <3 x i32>
  %i4out2 = alloca <4 x i32>
  %i4out1 = alloca <4 x i32>
  %u4out = alloca <4 x i32>
  %u1out = alloca i32
  %u2out = alloca <2 x i32>
  br label %mainBody

mainBody:                                         ; preds = %entry
  store <4 x i32> zeroinitializer, <4 x i32>* @iout
  store <4 x i32> zeroinitializer, <4 x i32>* @uout
  store <4 x float> zeroinitializer, <4 x float>* @fout
  %0 = load <2 x i32>* @u2
  %1 = load <2 x i32>* @u2
  %uout = call { <2 x i32>, <2 x i32> } @llvm.gla.addCarry.v2i32.v2i32.v2i32.v2i32(<2 x i32> %0, <2 x i32> %1), !gla.precision !35
  %u2out1 = extractvalue { <2 x i32>, <2 x i32> } %uout, 1
  store <2 x i32> %u2out1, <2 x i32>* %u2out
  %2 = extractvalue { <2 x i32>, <2 x i32> } %uout, 0
  %3 = load <4 x i32>* @uout
  %4 = extractelement <4 x i32> %3, i32 0, !gla.precision !35
  %5 = insertelement <2 x i32> undef, i32 %4, i32 0, !gla.precision !35
  %6 = extractelement <4 x i32> %3, i32 1, !gla.precision !35
  %7 = insertelement <2 x i32> %5, i32 %6, i32 1, !gla.precision !35
  %8 = add <2 x i32> %7, %2, !gla.precision !35
  %9 = extractelement <2 x i32> %8, i32 0
  store i32 %9, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %10 = extractelement <2 x i32> %8, i32 1
  store i32 %10, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 1)
  %11 = load <2 x i32>* %u2out
  %12 = load <4 x i32>* @uout
  %13 = extractelement <4 x i32> %12, i32 0, !gla.precision !35
  %14 = insertelement <2 x i32> undef, i32 %13, i32 0, !gla.precision !35
  %15 = extractelement <4 x i32> %12, i32 1, !gla.precision !35
  %16 = insertelement <2 x i32> %14, i32 %15, i32 1, !gla.precision !35
  %17 = add <2 x i32> %16, %11, !gla.precision !35
  %18 = extractelement <2 x i32> %17, i32 0
  store i32 %18, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %19 = extractelement <2 x i32> %17, i32 1
  store i32 %19, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 1)
  %20 = load i32* @u1
  %21 = load i32* @u1
  %uout2 = call { i32, i32 } @llvm.gla.subBorrow.i32.i32.i32.i32(i32 %20, i32 %21), !gla.precision !35
  %u1out3 = extractvalue { i32, i32 } %uout2, 1
  store i32 %u1out3, i32* %u1out
  %22 = extractvalue { i32, i32 } %uout2, 0
  %23 = load <4 x i32>* @uout
  %24 = extractelement <4 x i32> %23, i32 0, !gla.precision !35
  %25 = add i32 %24, %22, !gla.precision !35
  store i32 %25, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %26 = load i32* %u1out
  %27 = load <4 x i32>* @uout
  %28 = extractelement <4 x i32> %27, i32 0, !gla.precision !35
  %29 = add i32 %28, %26, !gla.precision !35
  store i32 %29, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %30 = load <4 x i32>* @u4
  %31 = load <4 x i32>* @u4
  %misc2a = call { <4 x i32>, <4 x i32> } @llvm.gla.umulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32> %30, <4 x i32> %31)
  %u4out4 = extractvalue { <4 x i32>, <4 x i32> } %misc2a, 0
  store <4 x i32> %u4out4, <4 x i32>* %u4out
  %u4out5 = extractvalue { <4 x i32>, <4 x i32> } %misc2a, 1
  store <4 x i32> %u4out5, <4 x i32>* %u4out
  %32 = load <4 x i32>* %u4out
  %33 = load <4 x i32>* @uout
  %uout6 = add <4 x i32> %33, %32, !gla.precision !35
  store <4 x i32> %uout6, <4 x i32>* @uout
  %34 = load <4 x i32>* @i4
  %35 = load <4 x i32>* @i4
  %misc2a7 = call { <4 x i32>, <4 x i32> } @llvm.gla.smulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32> %34, <4 x i32> %35)
  %i4out18 = extractvalue { <4 x i32>, <4 x i32> } %misc2a7, 0
  store <4 x i32> %i4out18, <4 x i32>* %i4out1
  %i4out29 = extractvalue { <4 x i32>, <4 x i32> } %misc2a7, 1
  store <4 x i32> %i4out29, <4 x i32>* %i4out2
  %36 = load <4 x i32>* %i4out1
  %37 = load <4 x i32>* %i4out2
  %38 = add <4 x i32> %36, %37, !gla.precision !35
  %39 = load <4 x i32>* @iout
  %iout = add <4 x i32> %39, %38, !gla.precision !35
  store <4 x i32> %iout, <4 x i32>* @iout
  %40 = load i32* @i1
  %iout10 = call i32 @llvm.gla.sBitFieldExtract.i32.i32(i32 %40, i32 4, i32 5), !gla.precision !35
  %41 = load <4 x i32>* @iout
  %42 = extractelement <4 x i32> %41, i32 0, !gla.precision !35
  %43 = add i32 %42, %iout10, !gla.precision !35
  store i32 %43, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %44 = load <3 x i32>* @u3
  %uout11 = call <3 x i32> @llvm.gla.uBitFieldExtract.v3i32.v3i32(<3 x i32> %44, i32 4, i32 5), !gla.precision !35
  %45 = load <4 x i32>* @uout
  %46 = extractelement <4 x i32> %45, i32 0, !gla.precision !35
  %47 = insertelement <3 x i32> undef, i32 %46, i32 0, !gla.precision !35
  %48 = extractelement <4 x i32> %45, i32 1, !gla.precision !35
  %49 = insertelement <3 x i32> %47, i32 %48, i32 1, !gla.precision !35
  %50 = extractelement <4 x i32> %45, i32 2, !gla.precision !35
  %51 = insertelement <3 x i32> %49, i32 %50, i32 2, !gla.precision !35
  %52 = add <3 x i32> %51, %uout11, !gla.precision !35
  %53 = extractelement <3 x i32> %52, i32 0
  store i32 %53, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %54 = extractelement <3 x i32> %52, i32 1
  store i32 %54, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 1)
  %55 = extractelement <3 x i32> %52, i32 2
  store i32 %55, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 2)
  %56 = load <3 x i32>* @i3
  %57 = load <3 x i32>* @i3
  %iout12 = call <3 x i32> @llvm.gla.bitFieldInsert.v3i32.v3i32.v3i32(<3 x i32> %56, <3 x i32> %57, i32 4, i32 5), !gla.precision !35
  %58 = load <4 x i32>* @iout
  %59 = extractelement <4 x i32> %58, i32 0, !gla.precision !35
  %60 = insertelement <3 x i32> undef, i32 %59, i32 0, !gla.precision !35
  %61 = extractelement <4 x i32> %58, i32 1, !gla.precision !35
  %62 = insertelement <3 x i32> %60, i32 %61, i32 1, !gla.precision !35
  %63 = extractelement <4 x i32> %58, i32 2, !gla.precision !35
  %64 = insertelement <3 x i32> %62, i32 %63, i32 2, !gla.precision !35
  %65 = add <3 x i32> %64, %iout12, !gla.precision !35
  %66 = extractelement <3 x i32> %65, i32 0
  store i32 %66, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %67 = extractelement <3 x i32> %65, i32 1
  store i32 %67, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 1)
  %68 = extractelement <3 x i32> %65, i32 2
  store i32 %68, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 2)
  %69 = load i32* @u1
  %70 = load i32* @u1
  %uout13 = call i32 @llvm.gla.bitFieldInsert.i32.i32.i32(i32 %69, i32 %70, i32 4, i32 5), !gla.precision !35
  %71 = load <4 x i32>* @uout
  %72 = extractelement <4 x i32> %71, i32 0, !gla.precision !35
  %73 = add i32 %72, %uout13, !gla.precision !35
  store i32 %73, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %74 = load <2 x i32>* @i2
  %iout14 = call <2 x i32> @llvm.gla.bitReverse.v2i32.v2i32(<2 x i32> %74), !gla.precision !35
  %75 = load <4 x i32>* @iout
  %76 = extractelement <4 x i32> %75, i32 0, !gla.precision !35
  %77 = insertelement <2 x i32> undef, i32 %76, i32 0, !gla.precision !35
  %78 = extractelement <4 x i32> %75, i32 1, !gla.precision !35
  %79 = insertelement <2 x i32> %77, i32 %78, i32 1, !gla.precision !35
  %80 = add <2 x i32> %79, %iout14, !gla.precision !35
  %81 = extractelement <2 x i32> %80, i32 0
  store i32 %81, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %82 = extractelement <2 x i32> %80, i32 1
  store i32 %82, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 1)
  %83 = load <4 x i32>* @u4
  %uout15 = call <4 x i32> @llvm.gla.bitReverse.v4i32.v4i32(<4 x i32> %83), !gla.precision !35
  %84 = load <4 x i32>* @uout
  %uout16 = add <4 x i32> %84, %uout15, !gla.precision !35
  store <4 x i32> %uout16, <4 x i32>* @uout
  %85 = load i32* @i1
  %iout17 = call i32 @llvm.gla.bitCount.i32.i32(i32 %85), !gla.precision !35
  %86 = load <4 x i32>* @iout
  %87 = extractelement <4 x i32> %86, i32 0, !gla.precision !35
  %88 = add i32 %87, %iout17, !gla.precision !35
  store i32 %88, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %89 = load <3 x i32>* @u3
  %iout18 = call <3 x i32> @llvm.gla.bitCount.v3i32.v3i32(<3 x i32> %89), !gla.precision !35
  %90 = load <4 x i32>* @iout
  %91 = extractelement <4 x i32> %90, i32 0, !gla.precision !35
  %92 = insertelement <3 x i32> undef, i32 %91, i32 0, !gla.precision !35
  %93 = extractelement <4 x i32> %90, i32 1, !gla.precision !35
  %94 = insertelement <3 x i32> %92, i32 %93, i32 1, !gla.precision !35
  %95 = extractelement <4 x i32> %90, i32 2, !gla.precision !35
  %96 = insertelement <3 x i32> %94, i32 %95, i32 2, !gla.precision !35
  %97 = add <3 x i32> %96, %iout18, !gla.precision !35
  %98 = extractelement <3 x i32> %97, i32 0
  store i32 %98, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %99 = extractelement <3 x i32> %97, i32 1
  store i32 %99, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 1)
  %100 = extractelement <3 x i32> %97, i32 2
  store i32 %100, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 2)
  %101 = load <2 x i32>* @i2
  %iout19 = call <2 x i32> @llvm.gla.findLSB.v2i32.v2i32(<2 x i32> %101), !gla.precision !35
  %102 = load <4 x i32>* @iout
  %103 = extractelement <4 x i32> %102, i32 0, !gla.precision !35
  %104 = insertelement <2 x i32> undef, i32 %103, i32 0, !gla.precision !35
  %105 = extractelement <4 x i32> %102, i32 1, !gla.precision !35
  %106 = insertelement <2 x i32> %104, i32 %105, i32 1, !gla.precision !35
  %107 = add <2 x i32> %106, %iout19, !gla.precision !35
  %108 = extractelement <2 x i32> %107, i32 0
  store i32 %108, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %109 = extractelement <2 x i32> %107, i32 1
  store i32 %109, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 1)
  %110 = load <4 x i32>* @u4
  %iout20 = call <4 x i32> @llvm.gla.findLSB.v4i32.v4i32(<4 x i32> %110), !gla.precision !35
  %111 = load <4 x i32>* @iout
  %iout21 = add <4 x i32> %111, %iout20, !gla.precision !35
  store <4 x i32> %iout21, <4 x i32>* @iout
  %112 = load i32* @i1
  %iout22 = call i32 @llvm.gla.sFindMSB.i32.i32(i32 %112), !gla.precision !35
  %113 = load <4 x i32>* @iout
  %114 = extractelement <4 x i32> %113, i32 0, !gla.precision !35
  %115 = add i32 %114, %iout22, !gla.precision !35
  store i32 %115, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %116 = load <2 x i32>* @u2
  %iout23 = call <2 x i32> @llvm.gla.sFindMSB.v2i32.v2i32(<2 x i32> %116), !gla.precision !35
  %117 = load <4 x i32>* @iout
  %118 = extractelement <4 x i32> %117, i32 0, !gla.precision !35
  %119 = insertelement <2 x i32> undef, i32 %118, i32 0, !gla.precision !35
  %120 = extractelement <4 x i32> %117, i32 1, !gla.precision !35
  %121 = insertelement <2 x i32> %119, i32 %120, i32 1, !gla.precision !35
  %122 = add <2 x i32> %121, %iout23, !gla.precision !35
  %123 = extractelement <2 x i32> %122, i32 0
  store i32 %123, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %124 = extractelement <2 x i32> %122, i32 1
  store i32 %124, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 1)
  %125 = load <3 x float>* @v3
  %fout = call { <3 x float>, <3 x i32> } @llvm.gla.fFrexp.v3f32.v3i32.v3f32(<3 x float> %125), !gla.precision !35
  %i3out24 = extractvalue { <3 x float>, <3 x i32> } %fout, 1
  store <3 x i32> %i3out24, <3 x i32>* %i3out
  %126 = extractvalue { <3 x float>, <3 x i32> } %fout, 0
  %127 = load <4 x float>* @fout
  %128 = extractelement <4 x float> %127, i32 0, !gla.precision !35
  %129 = insertelement <3 x float> undef, float %128, i32 0, !gla.precision !35
  %130 = extractelement <4 x float> %127, i32 1, !gla.precision !35
  %131 = insertelement <3 x float> %129, float %130, i32 1, !gla.precision !35
  %132 = extractelement <4 x float> %127, i32 2, !gla.precision !35
  %133 = insertelement <3 x float> %131, float %132, i32 2, !gla.precision !35
  %134 = fadd <3 x float> %133, %126, !gla.precision !35
  %135 = extractelement <3 x float> %134, i32 0
  store float %135, float* getelementptr inbounds (<4 x float>* @fout, i32 0, i32 0)
  %136 = extractelement <3 x float> %134, i32 1
  store float %136, float* getelementptr inbounds (<4 x float>* @fout, i32 0, i32 1)
  %137 = extractelement <3 x float> %134, i32 2
  store float %137, float* getelementptr inbounds (<4 x float>* @fout, i32 0, i32 2)
  %138 = load <3 x i32>* %i3out
  %139 = load <4 x i32>* @iout
  %140 = extractelement <4 x i32> %139, i32 0, !gla.precision !35
  %141 = insertelement <3 x i32> undef, i32 %140, i32 0, !gla.precision !35
  %142 = extractelement <4 x i32> %139, i32 1, !gla.precision !35
  %143 = insertelement <3 x i32> %141, i32 %142, i32 1, !gla.precision !35
  %144 = extractelement <4 x i32> %139, i32 2, !gla.precision !35
  %145 = insertelement <3 x i32> %143, i32 %144, i32 2, !gla.precision !35
  %146 = add <3 x i32> %145, %138, !gla.precision !35
  %147 = extractelement <3 x i32> %146, i32 0
  store i32 %147, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %148 = extractelement <3 x i32> %146, i32 1
  store i32 %148, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 1)
  %149 = extractelement <3 x i32> %146, i32 2
  store i32 %149, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 2)
  %150 = load float* @v1
  %fout25 = call { float, i32 } @llvm.gla.fFrexp.f32.i32.f32(float %150), !gla.precision !35
  %i1out26 = extractvalue { float, i32 } %fout25, 1
  store i32 %i1out26, i32* %i1out
  %151 = extractvalue { float, i32 } %fout25, 0
  %152 = load <4 x float>* @fout
  %153 = extractelement <4 x float> %152, i32 0, !gla.precision !35
  %154 = fadd float %153, %151, !gla.precision !35
  store float %154, float* getelementptr inbounds (<4 x float>* @fout, i32 0, i32 0)
  %155 = load i32* %i1out
  %156 = load <4 x i32>* @iout
  %157 = extractelement <4 x i32> %156, i32 0, !gla.precision !35
  %158 = add i32 %157, %155, !gla.precision !35
  store i32 %158, i32* getelementptr inbounds (<4 x i32>* @iout, i32 0, i32 0)
  %159 = load <2 x float>* @v2
  %160 = load <2 x i32>* @i2
  %fout27 = call <2 x float> @llvm.gla.fLdexp.v2f32.v2f32.v2i32(<2 x float> %159, <2 x i32> %160), !gla.precision !35
  %161 = load <4 x float>* @fout
  %162 = extractelement <4 x float> %161, i32 0, !gla.precision !35
  %163 = insertelement <2 x float> undef, float %162, i32 0, !gla.precision !35
  %164 = extractelement <4 x float> %161, i32 1, !gla.precision !35
  %165 = insertelement <2 x float> %163, float %164, i32 1, !gla.precision !35
  %166 = fadd <2 x float> %165, %fout27, !gla.precision !35
  %167 = extractelement <2 x float> %166, i32 0
  store float %167, float* getelementptr inbounds (<4 x float>* @fout, i32 0, i32 0)
  %168 = extractelement <2 x float> %166, i32 1
  store float %168, float* getelementptr inbounds (<4 x float>* @fout, i32 0, i32 1)
  %169 = load float* @v1
  %170 = load i32* @i1
  %fout28 = call float @llvm.gla.fLdexp.f32.f32.i32(float %169, i32 %170), !gla.precision !35
  %171 = load <4 x float>* @fout
  %172 = extractelement <4 x float> %171, i32 0, !gla.precision !35
  %173 = fadd float %172, %fout28, !gla.precision !35
  store float %173, float* getelementptr inbounds (<4 x float>* @fout, i32 0, i32 0)
  %174 = load <4 x float>* @v4
  %uout29 = call i32 @llvm.gla.fPackUnorm4x8.i32.v4f32(<4 x float> %174), !gla.precision !35
  %175 = load <4 x i32>* @uout
  %176 = extractelement <4 x i32> %175, i32 0, !gla.precision !35
  %177 = add i32 %176, %uout29, !gla.precision !35
  store i32 %177, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %178 = load <4 x float>* @v4
  %uout30 = call i32 @llvm.gla.fPackSnorm4x8.i32.v4f32(<4 x float> %178), !gla.precision !35
  %179 = load <4 x i32>* @uout
  %180 = extractelement <4 x i32> %179, i32 0, !gla.precision !35
  %181 = add i32 %180, %uout30, !gla.precision !35
  store i32 %181, i32* getelementptr inbounds (<4 x i32>* @uout, i32 0, i32 0)
  %182 = load i32* @u1
  %fout31 = call <4 x float> @llvm.gla.fUnpackUnorm4x8.v4f32.i32(i32 %182), !gla.precision !36
  %183 = load <4 x float>* @fout
  %fout32 = fadd <4 x float> %183, %fout31, !gla.precision !35
  store <4 x float> %fout32, <4 x float>* @fout
  %184 = load i32* @u1
  %fout33 = call <4 x float> @llvm.gla.fUnpackSnorm4x8.v4f32.i32(i32 %184), !gla.precision !36
  %185 = load <4 x float>* @fout
  %fout34 = fadd <4 x float> %185, %fout33, !gla.precision !35
  store <4 x float> %fout34, <4 x float>* @fout
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %mainBody
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare { <2 x i32>, <2 x i32> } @llvm.gla.addCarry.v2i32.v2i32.v2i32.v2i32(<2 x i32>, <2 x i32>) #0

; Function Attrs: nounwind readnone
declare { i32, i32 } @llvm.gla.subBorrow.i32.i32.i32.i32(i32, i32) #0

; Function Attrs: nounwind readnone
declare { <4 x i32>, <4 x i32> } @llvm.gla.umulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32>, <4 x i32>) #0

; Function Attrs: nounwind readnone
declare { <4 x i32>, <4 x i32> } @llvm.gla.smulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32>, <4 x i32>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.sBitFieldExtract.i32.i32(i32, i32, i32) #0

; Function Attrs: nounwind readnone
declare <3 x i32> @llvm.gla.uBitFieldExtract.v3i32.v3i32(<3 x i32>, i32, i32) #0

; Function Attrs: nounwind readnone
declare <3 x i32> @llvm.gla.bitFieldInsert.v3i32.v3i32.v3i32(<3 x i32>, <3 x i32>, i32, i32) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.bitFieldInsert.i32.i32.i32(i32, i32, i32, i32) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.bitReverse.v2i32.v2i32(<2 x i32>) #0

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.bitReverse.v4i32.v4i32(<4 x i32>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.bitCount.i32.i32(i32) #0

; Function Attrs: nounwind readnone
declare <3 x i32> @llvm.gla.bitCount.v3i32.v3i32(<3 x i32>) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.findLSB.v2i32.v2i32(<2 x i32>) #0

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.findLSB.v4i32.v4i32(<4 x i32>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.sFindMSB.i32.i32(i32) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.sFindMSB.v2i32.v2i32(<2 x i32>) #0

; Function Attrs: nounwind readnone
declare { <3 x float>, <3 x i32> } @llvm.gla.fFrexp.v3f32.v3i32.v3f32(<3 x float>) #0

; Function Attrs: nounwind readnone
declare { float, i32 } @llvm.gla.fFrexp.f32.i32.f32(float) #0

; Function Attrs: nounwind readnone
declare <2 x float> @llvm.gla.fLdexp.v2f32.v2f32.v2i32(<2 x float>, <2 x i32>) #0

; Function Attrs: nounwind readnone
declare float @llvm.gla.fLdexp.f32.f32.i32(float, i32) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.fPackUnorm4x8.i32.v4f32(<4 x float>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.fPackSnorm4x8.i32.v4f32(<4 x float>) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fUnpackUnorm4x8.v4f32.i32(i32) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fUnpackSnorm4x8.v4f32.i32(i32) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1, !3, !5}
!gla.inputs = !{!7, !9, !11, !13, !15, !17, !19, !21, !23, !25, !27, !29, !31, !33}
!gla.noStaticUse = !{!31, !33}

!0 = !{!"main", i32 15}
!1 = !{!"iout", i32 7, <4 x i32>* @iout_typeProxy, !2, !""}
!2 = !{i32 0, i32 3, i32 1024, null, i32 1, i32 0, i32 -1, i32 0, i32 -1}
!3 = !{!"uout", i32 7, <4 x i32>* @uout_typeProxy, !4, !""}
!4 = !{i32 1, i32 3, i32 1025, null, i32 1, i32 0, i32 -1, i32 0, i32 -1}
!5 = !{!"fout", i32 7, <4 x float>* @fout_typeProxy, !6, !""}
!6 = !{i32 0, i32 3, i32 1026, null, i32 1, i32 0, i32 -1, i32 0, i32 -1}
!7 = !{!"u2", i32 1, <2 x i32>* @u2_typeProxy, !8, !""}
!8 = !{i32 1, i32 3, i32 1027, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!9 = !{!"u1", i32 1, i32* @u1_typeProxy, !10, !""}
!10 = !{i32 1, i32 3, i32 1028, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!11 = !{!"u4", i32 1, <4 x i32>* @u4_typeProxy, !12, !""}
!12 = !{i32 1, i32 3, i32 1029, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!13 = !{!"i4", i32 1, <4 x i32>* @i4_typeProxy, !14, !""}
!14 = !{i32 0, i32 3, i32 1030, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!15 = !{!"i1", i32 1, i32* @i1_typeProxy, !16, !""}
!16 = !{i32 0, i32 3, i32 1031, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!17 = !{!"u3", i32 1, <3 x i32>* @u3_typeProxy, !18, !""}
!18 = !{i32 1, i32 3, i32 1032, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!19 = !{!"i3", i32 1, <3 x i32>* @i3_typeProxy, !20, !""}
!20 = !{i32 0, i32 3, i32 1033, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!21 = !{!"i2", i32 1, <2 x i32>* @i2_typeProxy, !22, !""}
!22 = !{i32 0, i32 3, i32 1034, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!23 = !{!"v3", i32 1, <3 x float>* @v3_typeProxy, !24, !""}
!24 = !{i32 0, i32 3, i32 1035, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!25 = !{!"v1", i32 1, float* @v1_typeProxy, !26, !""}
!26 = !{i32 0, i32 3, i32 1036, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!27 = !{!"v2", i32 1, <2 x float>* @v2_typeProxy, !28, !""}
!28 = !{i32 0, i32 3, i32 1037, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!29 = !{!"v4", i32 1, <4 x float>* @v4_typeProxy, !30, !""}
!30 = !{i32 0, i32 3, i32 1038, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!31 = !{!"gl_VertexID", i32 2, i32* @gl_VertexID_typeProxy, !32, !""}
!32 = !{i32 0, i32 3, i32 1039, null, i32 0, i32 7, i32 -1, i32 0, i32 -1}
!33 = !{!"gl_InstanceID", i32 3, i32* @gl_InstanceID_typeProxy, !34, !""}
!34 = !{i32 0, i32 3, i32 1040, null, i32 0, i32 8, i32 -1, i32 0, i32 -1}
!35 = !{i32 3}
!36 = !{i32 2}


Bottom IR:
; ModuleID = 'Glslang'
target datalayout = "e-p:32:32"

@iout = global <4 x i32> zeroinitializer
@uout = global <4 x i32> zeroinitializer
@fout = global <4 x float> zeroinitializer
@u2 = global <2 x i32> zeroinitializer
@u1 = global i32 0
@u4 = global <4 x i32> zeroinitializer
@i4 = global <4 x i32> zeroinitializer
@i1 = global i32 0
@u3 = global <3 x i32> zeroinitializer
@i3 = global <3 x i32> zeroinitializer
@i2 = global <2 x i32> zeroinitializer
@v3 = global <3 x float> zeroinitializer
@v1 = global float 0.000000e+00
@v2 = global <2 x float> zeroinitializer
@v4 = global <4 x float> zeroinitializer
@gl_VertexID = global i32 0
@gl_InstanceID = global i32 0

define fastcc void @main() {
entry:
  store <4 x i32> zeroinitializer, <4 x i32>* @iout
  store <4 x i32> zeroinitializer, <4 x i32>* @uout
  store <4 x float> zeroinitializer, <4 x float>* @fout
  %0 = load <2 x i32>* @u2
  %uout = call { <2 x i32>, <2 x i32> } @llvm.gla.addCarry.v2i32.v2i32.v2i32.v2i32(<2 x i32> %0, <2 x i32> %0), !gla.precision !35
  %u2out1 = extractvalue { <2 x i32>, <2 x i32> } %uout, 1
  %1 = extractvalue { <2 x i32>, <2 x i32> } %uout, 0
  %2 = extractelement <2 x i32> %1, i32 0
  %gla_constGEP = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %2, i32* %gla_constGEP
  %3 = extractelement <2 x i32> %1, i32 1
  %gla_constGEP35 = getelementptr <4 x i32>* @uout, i32 0, i32 1
  store i32 %3, i32* %gla_constGEP35
  %4 = load <4 x i32>* @uout
  %5 = call <2 x i32> @llvm.gla.swizzle.v2i32.v4i32.v2i32(<4 x i32> %4, <2 x i32> <i32 0, i32 1>)
  %6 = add <2 x i32> %u2out1, %5, !gla.precision !35
  %7 = extractelement <2 x i32> %6, i32 0
  %gla_constGEP36 = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %7, i32* %gla_constGEP36
  %8 = extractelement <2 x i32> %6, i32 1
  %gla_constGEP37 = getelementptr <4 x i32>* @uout, i32 0, i32 1
  store i32 %8, i32* %gla_constGEP37
  %9 = load i32* @u1
  %uout2 = call { i32, i32 } @llvm.gla.subBorrow.i32.i32.i32.i32(i32 %9, i32 %9), !gla.precision !35
  %u1out3 = extractvalue { i32, i32 } %uout2, 1
  %10 = extractvalue { i32, i32 } %uout2, 0
  %11 = load <4 x i32>* @uout
  %12 = extractelement <4 x i32> %11, i32 0, !gla.precision !35
  %13 = add i32 %12, %10, !gla.precision !35
  %gla_constGEP38 = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %13, i32* %gla_constGEP38
  %14 = load <4 x i32>* @uout
  %15 = extractelement <4 x i32> %14, i32 0, !gla.precision !35
  %16 = add i32 %15, %u1out3, !gla.precision !35
  %gla_constGEP39 = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %16, i32* %gla_constGEP39
  %17 = load <4 x i32>* @u4
  %misc2a = call { <4 x i32>, <4 x i32> } @llvm.gla.umulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32> %17, <4 x i32> %17)
  %u4out5 = extractvalue { <4 x i32>, <4 x i32> } %misc2a, 1
  %18 = load <4 x i32>* @uout
  %uout6 = add <4 x i32> %18, %u4out5, !gla.precision !35
  %19 = call <3 x i32> @llvm.gla.swizzle.v3i32.v4i32.v3i32(<4 x i32> %uout6, <3 x i32> <i32 0, i32 1, i32 2>)
  store <4 x i32> %uout6, <4 x i32>* @uout
  %20 = load <4 x i32>* @i4
  %misc2a7 = call { <4 x i32>, <4 x i32> } @llvm.gla.smulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32> %20, <4 x i32> %20)
  %i4out18 = extractvalue { <4 x i32>, <4 x i32> } %misc2a7, 0
  %i4out29 = extractvalue { <4 x i32>, <4 x i32> } %misc2a7, 1
  %21 = add <4 x i32> %i4out18, %i4out29, !gla.precision !35
  store <4 x i32> %21, <4 x i32>* @iout
  %22 = load i32* @i1
  %iout10 = call i32 @llvm.gla.sBitFieldExtract.i32.i32(i32 %22, i32 4, i32 5), !gla.precision !35
  %23 = extractelement <4 x i32> %21, i32 0, !gla.precision !35
  %24 = add i32 %23, %iout10, !gla.precision !35
  %gla_constGEP40 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %24, i32* %gla_constGEP40
  %25 = load <3 x i32>* @u3
  %uout11 = call <3 x i32> @llvm.gla.uBitFieldExtract.v3i32.v3i32(<3 x i32> %25, i32 4, i32 5), !gla.precision !35
  %26 = add <3 x i32> %uout11, %19, !gla.precision !35
  %27 = extractelement <3 x i32> %26, i32 0
  %gla_constGEP41 = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %27, i32* %gla_constGEP41
  %28 = extractelement <3 x i32> %26, i32 1
  %gla_constGEP42 = getelementptr <4 x i32>* @uout, i32 0, i32 1
  store i32 %28, i32* %gla_constGEP42
  %29 = extractelement <3 x i32> %26, i32 2
  %gla_constGEP43 = getelementptr <4 x i32>* @uout, i32 0, i32 2
  store i32 %29, i32* %gla_constGEP43
  %30 = load <3 x i32>* @i3
  %iout12 = call <3 x i32> @llvm.gla.bitFieldInsert.v3i32.v3i32.v3i32(<3 x i32> %30, <3 x i32> %30, i32 4, i32 5), !gla.precision !35
  %31 = load <4 x i32>* @iout
  %32 = call <3 x i32> @llvm.gla.swizzle.v3i32.v4i32.v3i32(<4 x i32> %31, <3 x i32> <i32 0, i32 1, i32 2>)
  %33 = add <3 x i32> %iout12, %32, !gla.precision !35
  %34 = extractelement <3 x i32> %33, i32 0
  %gla_constGEP44 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %34, i32* %gla_constGEP44
  %35 = extractelement <3 x i32> %33, i32 1
  %gla_constGEP45 = getelementptr <4 x i32>* @iout, i32 0, i32 1
  store i32 %35, i32* %gla_constGEP45
  %36 = extractelement <3 x i32> %33, i32 2
  %gla_constGEP46 = getelementptr <4 x i32>* @iout, i32 0, i32 2
  store i32 %36, i32* %gla_constGEP46
  %uout13 = call i32 @llvm.gla.bitFieldInsert.i32.i32.i32(i32 %9, i32 %9, i32 4, i32 5), !gla.precision !35
  %37 = load <4 x i32>* @uout
  %38 = extractelement <4 x i32> %37, i32 0, !gla.precision !35
  %39 = add i32 %38, %uout13, !gla.precision !35
  %gla_constGEP47 = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %39, i32* %gla_constGEP47
  %40 = load <2 x i32>* @i2
  %iout14 = call <2 x i32> @llvm.gla.bitReverse.v2i32.v2i32(<2 x i32> %40), !gla.precision !35
  %41 = load <4 x i32>* @iout
  %42 = call <2 x i32> @llvm.gla.swizzle.v2i32.v4i32.v2i32(<4 x i32> %41, <2 x i32> <i32 0, i32 1>)
  %43 = add <2 x i32> %iout14, %42, !gla.precision !35
  %44 = extractelement <2 x i32> %43, i32 0
  %gla_constGEP48 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %44, i32* %gla_constGEP48
  %45 = extractelement <2 x i32> %43, i32 1
  %gla_constGEP49 = getelementptr <4 x i32>* @iout, i32 0, i32 1
  store i32 %45, i32* %gla_constGEP49
  %uout15 = call <4 x i32> @llvm.gla.bitReverse.v4i32.v4i32(<4 x i32> %17), !gla.precision !35
  %46 = load <4 x i32>* @uout
  %uout16 = add <4 x i32> %uout15, %46, !gla.precision !35
  store <4 x i32> %uout16, <4 x i32>* @uout
  %iout17 = call i32 @llvm.gla.bitCount.i32.i32(i32 %22), !gla.precision !35
  %47 = load <4 x i32>* @iout
  %48 = extractelement <4 x i32> %47, i32 0, !gla.precision !35
  %49 = add i32 %48, %iout17, !gla.precision !35
  %gla_constGEP50 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %49, i32* %gla_constGEP50
  %iout18 = call <3 x i32> @llvm.gla.bitCount.v3i32.v3i32(<3 x i32> %25), !gla.precision !35
  %50 = load <4 x i32>* @iout
  %51 = call <3 x i32> @llvm.gla.swizzle.v3i32.v4i32.v3i32(<4 x i32> %50, <3 x i32> <i32 0, i32 1, i32 2>)
  %52 = add <3 x i32> %iout18, %51, !gla.precision !35
  %53 = extractelement <3 x i32> %52, i32 0
  %gla_constGEP51 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %53, i32* %gla_constGEP51
  %54 = extractelement <3 x i32> %52, i32 1
  %gla_constGEP52 = getelementptr <4 x i32>* @iout, i32 0, i32 1
  store i32 %54, i32* %gla_constGEP52
  %55 = extractelement <3 x i32> %52, i32 2
  %gla_constGEP53 = getelementptr <4 x i32>* @iout, i32 0, i32 2
  store i32 %55, i32* %gla_constGEP53
  %iout19 = call <2 x i32> @llvm.gla.findLSB.v2i32.v2i32(<2 x i32> %40), !gla.precision !35
  %56 = load <4 x i32>* @iout
  %57 = call <2 x i32> @llvm.gla.swizzle.v2i32.v4i32.v2i32(<4 x i32> %56, <2 x i32> <i32 0, i32 1>)
  %58 = add <2 x i32> %iout19, %57, !gla.precision !35
  %59 = extractelement <2 x i32> %58, i32 0
  %gla_constGEP54 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %59, i32* %gla_constGEP54
  %60 = extractelement <2 x i32> %58, i32 1
  %gla_constGEP55 = getelementptr <4 x i32>* @iout, i32 0, i32 1
  store i32 %60, i32* %gla_constGEP55
  %iout20 = call <4 x i32> @llvm.gla.findLSB.v4i32.v4i32(<4 x i32> %17), !gla.precision !35
  %61 = load <4 x i32>* @iout
  %iout21 = add <4 x i32> %iout20, %61, !gla.precision !35
  store <4 x i32> %iout21, <4 x i32>* @iout
  %iout22 = call i32 @llvm.gla.sFindMSB.i32.i32(i32 %22), !gla.precision !35
  %62 = extractelement <4 x i32> %iout21, i32 0, !gla.precision !35
  %63 = add i32 %62, %iout22, !gla.precision !35
  %gla_constGEP56 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %63, i32* %gla_constGEP56
  %64 = load <2 x i32>* @u2
  %iout23 = call <2 x i32> @llvm.gla.sFindMSB.v2i32.v2i32(<2 x i32> %64), !gla.precision !35
  %65 = load <4 x i32>* @iout
  %66 = call <2 x i32> @llvm.gla.swizzle.v2i32.v4i32.v2i32(<4 x i32> %65, <2 x i32> <i32 0, i32 1>)
  %67 = add <2 x i32> %iout23, %66, !gla.precision !35
  %68 = extractelement <2 x i32> %67, i32 0
  %gla_constGEP57 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %68, i32* %gla_constGEP57
  %69 = extractelement <2 x i32> %67, i32 1
  %gla_constGEP58 = getelementptr <4 x i32>* @iout, i32 0, i32 1
  store i32 %69, i32* %gla_constGEP58
  %70 = load <3 x float>* @v3
  %fout = call { <3 x float>, <3 x i32> } @llvm.gla.fFrexp.v3f32.v3i32.v3f32(<3 x float> %70), !gla.precision !35
  %i3out24 = extractvalue { <3 x float>, <3 x i32> } %fout, 1
  %71 = extractvalue { <3 x float>, <3 x i32> } %fout, 0
  %72 = load <4 x float>* @fout
  %73 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %72, <3 x i32> <i32 0, i32 1, i32 2>)
  %74 = fadd <3 x float> %71, %73, !gla.precision !35
  %75 = extractelement <3 x float> %74, i32 0
  %gla_constGEP59 = getelementptr <4 x float>* @fout, i32 0, i32 0
  store float %75, float* %gla_constGEP59
  %76 = extractelement <3 x float> %74, i32 1
  %gla_constGEP60 = getelementptr <4 x float>* @fout, i32 0, i32 1
  store float %76, float* %gla_constGEP60
  %77 = extractelement <3 x float> %74, i32 2
  %gla_constGEP61 = getelementptr <4 x float>* @fout, i32 0, i32 2
  store float %77, float* %gla_constGEP61
  %78 = load <4 x i32>* @iout
  %79 = call <3 x i32> @llvm.gla.swizzle.v3i32.v4i32.v3i32(<4 x i32> %78, <3 x i32> <i32 0, i32 1, i32 2>)
  %80 = add <3 x i32> %i3out24, %79, !gla.precision !35
  %81 = extractelement <3 x i32> %80, i32 0
  %gla_constGEP62 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %81, i32* %gla_constGEP62
  %82 = extractelement <3 x i32> %80, i32 1
  %gla_constGEP63 = getelementptr <4 x i32>* @iout, i32 0, i32 1
  store i32 %82, i32* %gla_constGEP63
  %83 = extractelement <3 x i32> %80, i32 2
  %gla_constGEP64 = getelementptr <4 x i32>* @iout, i32 0, i32 2
  store i32 %83, i32* %gla_constGEP64
  %84 = load float* @v1
  %fout25 = call { float, i32 } @llvm.gla.fFrexp.f32.i32.f32(float %84), !gla.precision !35
  %i1out26 = extractvalue { float, i32 } %fout25, 1
  %85 = extractvalue { float, i32 } %fout25, 0
  %86 = load <4 x float>* @fout
  %87 = extractelement <4 x float> %86, i32 0, !gla.precision !35
  %88 = fadd float %85, %87, !gla.precision !35
  %gla_constGEP65 = getelementptr <4 x float>* @fout, i32 0, i32 0
  store float %88, float* %gla_constGEP65
  %89 = load <4 x i32>* @iout
  %90 = extractelement <4 x i32> %89, i32 0, !gla.precision !35
  %91 = add i32 %90, %i1out26, !gla.precision !35
  %gla_constGEP66 = getelementptr <4 x i32>* @iout, i32 0, i32 0
  store i32 %91, i32* %gla_constGEP66
  %92 = load <2 x float>* @v2
  %fout27 = call <2 x float> @llvm.gla.fLdexp.v2f32.v2f32.v2i32(<2 x float> %92, <2 x i32> %40), !gla.precision !35
  %93 = load <4 x float>* @fout
  %94 = call <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float> %93, <2 x i32> <i32 0, i32 1>)
  %95 = fadd <2 x float> %fout27, %94, !gla.precision !35
  %96 = extractelement <2 x float> %95, i32 0
  %gla_constGEP67 = getelementptr <4 x float>* @fout, i32 0, i32 0
  store float %96, float* %gla_constGEP67
  %97 = extractelement <2 x float> %95, i32 1
  %gla_constGEP68 = getelementptr <4 x float>* @fout, i32 0, i32 1
  store float %97, float* %gla_constGEP68
  %98 = load i32* @i1
  %fout28 = call float @llvm.gla.fLdexp.f32.f32.i32(float %84, i32 %98), !gla.precision !35
  %99 = load <4 x float>* @fout
  %100 = extractelement <4 x float> %99, i32 0, !gla.precision !35
  %101 = fadd float %fout28, %100, !gla.precision !35
  %gla_constGEP69 = getelementptr <4 x float>* @fout, i32 0, i32 0
  store float %101, float* %gla_constGEP69
  %102 = load <4 x float>* @v4
  %uout29 = call i32 @llvm.gla.fPackUnorm4x8.i32.v4f32(<4 x float> %102), !gla.precision !35
  %103 = extractelement <4 x i32> %uout16, i32 0, !gla.precision !35
  %104 = add i32 %103, %uout29, !gla.precision !35
  %gla_constGEP70 = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %104, i32* %gla_constGEP70
  %uout30 = call i32 @llvm.gla.fPackSnorm4x8.i32.v4f32(<4 x float> %102), !gla.precision !35
  %105 = load <4 x i32>* @uout
  %106 = extractelement <4 x i32> %105, i32 0, !gla.precision !35
  %107 = add i32 %106, %uout30, !gla.precision !35
  %gla_constGEP71 = getelementptr <4 x i32>* @uout, i32 0, i32 0
  store i32 %107, i32* %gla_constGEP71
  %108 = load i32* @u1
  %fout31 = call <4 x float> @llvm.gla.fUnpackUnorm4x8.v4f32.i32(i32 %108), !gla.precision !36
  %109 = load <4 x float>* @fout
  %fout32 = fadd <4 x float> %fout31, %109, !gla.precision !35
  %fout33 = call <4 x float> @llvm.gla.fUnpackSnorm4x8.v4f32.i32(i32 %108), !gla.precision !36
  %fout34 = fadd <4 x float> %fout32, %fout33, !gla.precision !35
  store <4 x float> %fout34, <4 x float>* @fout
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare { <2 x i32>, <2 x i32> } @llvm.gla.addCarry.v2i32.v2i32.v2i32.v2i32(<2 x i32>, <2 x i32>) #0

; Function Attrs: nounwind readnone
declare { i32, i32 } @llvm.gla.subBorrow.i32.i32.i32.i32(i32, i32) #0

; Function Attrs: nounwind readnone
declare { <4 x i32>, <4 x i32> } @llvm.gla.umulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32>, <4 x i32>) #0

; Function Attrs: nounwind readnone
declare { <4 x i32>, <4 x i32> } @llvm.gla.smulExtended.v4i32.v4i32.v4i32.v4i32(<4 x i32>, <4 x i32>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.sBitFieldExtract.i32.i32(i32, i32, i32) #0

; Function Attrs: nounwind readnone
declare <3 x i32> @llvm.gla.uBitFieldExtract.v3i32.v3i32(<3 x i32>, i32, i32) #0

; Function Attrs: nounwind readnone
declare <3 x i32> @llvm.gla.bitFieldInsert.v3i32.v3i32.v3i32(<3 x i32>, <3 x i32>, i32, i32) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.bitFieldInsert.i32.i32.i32(i32, i32, i32, i32) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.bitReverse.v2i32.v2i32(<2 x i32>) #0

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.bitReverse.v4i32.v4i32(<4 x i32>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.bitCount.i32.i32(i32) #0

; Function Attrs: nounwind readnone
declare <3 x i32> @llvm.gla.bitCount.v3i32.v3i32(<3 x i32>) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.findLSB.v2i32.v2i32(<2 x i32>) #0

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.findLSB.v4i32.v4i32(<4 x i32>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.sFindMSB.i32.i32(i32) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.sFindMSB.v2i32.v2i32(<2 x i32>) #0

; Function Attrs: nounwind readnone
declare { <3 x float>, <3 x i32> } @llvm.gla.fFrexp.v3f32.v3i32.v3f32(<3 x float>) #0

; Function Attrs: nounwind readnone
declare { float, i32 } @llvm.gla.fFrexp.f32.i32.f32(float) #0

; Function Attrs: nounwind readnone
declare <2 x float> @llvm.gla.fLdexp.v2f32.v2f32.v2i32(<2 x float>, <2 x i32>) #0

; Function Attrs: nounwind readnone
declare float @llvm.gla.fLdexp.f32.f32.i32(float, i32) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.fPackUnorm4x8.i32.v4f32(<4 x float>) #0

; Function Attrs: nounwind readnone
declare i32 @llvm.gla.fPackSnorm4x8.i32.v4f32(<4 x float>) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fUnpackUnorm4x8.v4f32.i32(i32) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fUnpackSnorm4x8.v4f32.i32(i32) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.swizzle.v2i32.v4i32.v2i32(<4 x i32>, <2 x i32>) #0

; Function Attrs: nounwind readnone
declare <3 x i32> @llvm.gla.swizzle.v3i32.v4i32.v3i32(<4 x i32>, <3 x i32>) #0

; Function Attrs: nounwind readnone
declare <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float>, <3 x i32>) #0

; Function Attrs: nounwind readnone
declare <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float>, <2 x i32>) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1, !3, !5}
!gla.inputs = !{!7, !9, !11, !13, !15, !17, !19, !21, !23, !25, !27, !29, !31, !33}
!gla.noStaticUse = !{!31, !33}

!0 = !{!"main", i32 15}
!1 = !{!"iout", i32 7, <4 x i32>* @iout_typeProxy, !2, !""}
!2 = !{i32 0, i32 3, i32 1024, null, i32 1, i32 0, i32 -1, i32 0, i32 -1}
!3 = !{!"uout", i32 7, <4 x i32>* @uout_typeProxy, !4, !""}
!4 = !{i32 1, i32 3, i32 1025, null, i32 1, i32 0, i32 -1, i32 0, i32 -1}
!5 = !{!"fout", i32 7, <4 x float>* @fout_typeProxy, !6, !""}
!6 = !{i32 0, i32 3, i32 1026, null, i32 1, i32 0, i32 -1, i32 0, i32 -1}
!7 = !{!"u2", i32 1, <2 x i32>* @u2_typeProxy, !8, !""}
!8 = !{i32 1, i32 3, i32 1027, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!9 = !{!"u1", i32 1, i32* @u1_typeProxy, !10, !""}
!10 = !{i32 1, i32 3, i32 1028, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!11 = !{!"u4", i32 1, <4 x i32>* @u4_typeProxy, !12, !""}
!12 = !{i32 1, i32 3, i32 1029, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!13 = !{!"i4", i32 1, <4 x i32>* @i4_typeProxy, !14, !""}
!14 = !{i32 0, i32 3, i32 1030, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!15 = !{!"i1", i32 1, i32* @i1_typeProxy, !16, !""}
!16 = !{i32 0, i32 3, i32 1031, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!17 = !{!"u3", i32 1, <3 x i32>* @u3_typeProxy, !18, !""}
!18 = !{i32 1, i32 3, i32 1032, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!19 = !{!"i3", i32 1, <3 x i32>* @i3_typeProxy, !20, !""}
!20 = !{i32 0, i32 3, i32 1033, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!21 = !{!"i2", i32 1, <2 x i32>* @i2_typeProxy, !22, !""}
!22 = !{i32 0, i32 3, i32 1034, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!23 = !{!"v3", i32 1, <3 x float>* @v3_typeProxy, !24, !""}
!24 = !{i32 0, i32 3, i32 1035, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!25 = !{!"v1", i32 1, float* @v1_typeProxy, !26, !""}
!26 = !{i32 0, i32 3, i32 1036, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!27 = !{!"v2", i32 1, <2 x float>* @v2_typeProxy, !28, !""}
!28 = !{i32 0, i32 3, i32 1037, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!29 = !{!"v4", i32 1, <4 x float>* @v4_typeProxy, !30, !""}
!30 = !{i32 0, i32 3, i32 1038, null, i32 0, i32 0, i32 -1, i32 0, i32 -1}
!31 = !{!"gl_VertexID", i32 2, i32* @gl_VertexID_typeProxy, !32, !""}
!32 = !{i32 0, i32 3, i32 1039, null, i32 0, i32 7, i32 -1, i32 0, i32 -1}
!33 = !{!"gl_InstanceID", i32 3, i32* @gl_InstanceID_typeProxy, !34, !""}
!34 = !{i32 0, i32 3, i32 1040, null, i32 0, i32 8, i32 -1, i32 0, i32 -1}
!35 = !{i32 3}
!36 = !{i32 2}
#version 310 es
// LunarGOO output
in highp uvec2 u2;
in highp uint u1;
in highp uvec4 u4;
in highp ivec4 i4;
in highp int i1;
in highp uvec3 u3;
in highp ivec3 i3;
in highp ivec2 i2;
in highp vec3 v3;
in highp float v1;
in highp vec2 v2;
in highp vec4 v4;
out highp ivec4 iout;
out highp uvec4 uout;
out highp vec4 fout;
const ivec4 C_ivec4p0p = ivec4(0);
const vec4 C_vec4p0d0p = vec4(0.0);
const int C_4 = 4;
const int C_5 = 5;

void main()
{
	iout = C_ivec4p0p;
	uout = uvec4(C_ivec4p0p);
	fout = C_vec4p0d0p;
	struct  {
	ivec2 member0;
	ivec2 member1;
} uout1; uout1.member0 = uaddCarry(ivec2(u2), ivec2(u2), uout1.member1);
	uout.x = uint(uout1.member0.x);
	uout.y = uint(uout1.member0.y);
	ivec2 H_74nbei = ivec4(uout).xy;
	highp ivec2 H_z6d8mg = H_74nbei + uout1.member1;
	uout.x = uint(H_z6d8mg.x);
	uout.y = uint(H_z6d8mg.y);
	struct  {
	int member0;
	int member1;
} uout2; uout2.member0 = usubBorrow(int(u1), int(u1), uout2.member1);
	highp int H_k6cc5a = ivec4(uout).x + uout2.member0;
	uout.x = uint(H_k6cc5a);
	highp int H_jvxbfa = ivec4(uout).x + uout2.member1;
	uout.x = uint(H_jvxbfa);
	struct  {
	ivec4 member0;
	ivec4 member1;
} misc2a; umulExtended(ivec4(u4), ivec4(u4), misc2a.member0, misc2a.member1);
	highp ivec4 uout3 = ivec4(uout) + misc2a.member1;
	uout = uvec4(uout3);
	struct  {
	ivec4 member0;
	ivec4 member1;
} misc2a1; imulExtended(i4, i4, misc2a1.member0, misc2a1.member1);
	highp ivec4 H_xh9cfj1 = misc2a1.member0 + misc2a1.member1;
	iout = H_xh9cfj1;
	highp int iout1 = bitfieldExtract(i1, C_4, C_5);
	highp int H_88tx4g = H_xh9cfj1.x + iout1;
	iout.x = H_88tx4g;
	highp ivec3 uout4 = ivec3(bitfieldExtract(uvec3(ivec3(u3)), C_4, C_5));
	highp ivec3 H_q2uee01 = uout3.xyz + uout4;
	uout.x = uint(H_q2uee01.x);
	uout.y = uint(H_q2uee01.y);
	uout.z = uint(H_q2uee01.z);
	highp ivec3 iout2 = bitfieldInsert(i3, i3, C_4, C_5);
	highp ivec3 H_pcw3yc = iout.xyz + iout2;
	iout.x = H_pcw3yc.x;
	iout.y = H_pcw3yc.y;
	iout.z = H_pcw3yc.z;
	highp int uout5 = bitfieldInsert(int(u1), int(u1), C_4, C_5);
	highp int H_15aupr = ivec4(uout).x + uout5;
	uout.x = uint(H_15aupr);
	highp ivec2 iout3 = bitfieldReverse(i2);
	highp ivec2 H_e07yz41 = iout.xy + iout3;
	iout.x = H_e07yz41.x;
	iout.y = H_e07yz41.y;
	highp ivec4 uout6 = bitfieldReverse(ivec4(u4));
	highp ivec4 uout7 = ivec4(uout) + uout6;
	uout = uvec4(uout7);
	highp int iout4 = bitCount(i1);
	highp int H_0w0iin1 = iout.x + iout4;
	iout.x = H_0w0iin1;
	highp ivec3 iout5 = bitCount(ivec3(u3));
	highp ivec3 H_o1i38d = iout.xyz + iout5;
	iout.x = H_o1i38d.x;
	iout.y = H_o1i38d.y;
	iout.z = H_o1i38d.z;
	highp ivec2 iout6 = findLSB(i2);
	highp ivec2 H_9h7wd61 = iout.xy + iout6;
	iout.x = H_9h7wd61.x;
	iout.y = H_9h7wd61.y;
	highp ivec4 iout7 = findLSB(ivec4(u4));
	highp ivec4 iout8 = iout + iout7;
	iout = iout8;
	highp int iout9 = findMSB(i1);
	highp int H_zj1xfg = iout8.x + iout9;
	iout.x = H_zj1xfg;
	highp ivec2 iouta = findMSB(ivec2(u2));
	highp ivec2 H_sb2i4r = iout.xy + iouta;
	iout.x = H_sb2i4r.x;
	iout.y = H_sb2i4r.y;
	struct  {
	vec3 member0;
	ivec3 member1;
} fout1; fout1.member0 = frexp(v3, fout1.member1);
	highp vec3 H_mmott7 = fout.xyz + fout1.member0;
	fout.x = H_mmott7.x;
	fout.y = H_mmott7.y;
	fout.z = H_mmott7.z;
	highp ivec3 H_0t099p1 = fout1.member1 + iout.xyz;
	iout.x = H_0t099p1.x;
	iout.y = H_0t099p1.y;
	iout.z = H_0t099p1.z;
	struct  {
	float member0;
	int member1;
} fout2; fout2.member0 = frexp(v1, fout2.member1);
	highp float H_4q98rk1 = fout.x + fout2.member0;
	fout.x = H_4q98rk1;
	highp int H_cnqmou1 = fout2.member1 + iout.x;
	iout.x = H_cnqmou1;
	highp vec2 fout3 = ldexp(v2, i2);
	highp vec2 H_6bwex9 = fout.xy + fout3;
	fout.x = H_6bwex9.x;
	fout.y = H_6bwex9.y;
	highp float fout4 = ldexp(v1, i1);
	highp float H_2sqfny1 = fout.x + fout4;
	fout.x = H_2sqfny1;
	highp int uout8 = int(packUnorm4x8(v4));
	highp int H_9w3o141 = uout7.x + uout8;
	uout.x = uint(H_9w3o141);
	highp int uout9 = int(packSnorm4x8(v4));
	highp int H_xwosts = ivec4(uout).x + uout9;
	uout.x = uint(H_xwosts);
	mediump vec4 fout5 = unpackUnorm4x8(uint(int(u1)));
	highp vec4 fout6 = fout + fout5;
	mediump vec4 fout7 = unpackSnorm4x8(uint(int(u1)));
	highp vec4 fout8 = fout6 + fout7;
	fout = fout8;
	
}

