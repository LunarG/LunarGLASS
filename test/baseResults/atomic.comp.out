
Top IR:
; ModuleID = 'Glslang'

%bname = type { <4 x i32>, i32 }

@atomi = addrspace(4) global i32 0
@atomu = addrspace(4) global i32 0
@value = external addrspace(2) constant i32
@binst = external addrspace(3) constant %bname
@counter = external addrspace(2) constant i32
@countArr = external addrspace(2) constant [4 x i32]
@arrX = internal global [1 x i32] zeroinitializer
@arrY = internal global [1 x i32] zeroinitializer
@arrZ = internal global [1 x i32] zeroinitializer

define fastcc void @main() {
entry:
  %val = alloca i32
  %param = alloca i32
  br label %mainBody

mainBody:                                         ; preds = %entry
  call void @llvm.gla.memoryBarrierAtomicCounter()
  call void @"atoms("()
  %param1 = load i32 addrspace(2)* @counter, !gla.uniform !10
  store i32 %param1, i32* %param
  %0 = call i32 @"func(au1;"(i32* %param)
  %1 = load i32 addrspace(2)* getelementptr inbounds ([4 x i32] addrspace(2)* @countArr, i32 0, i32 2), !gla.uniform !12
  %val2 = call i32 @llvm.gla.atomicCounterLoad(i32 %1), !gla.precision !15
  store i32 %val2, i32* %val
  %2 = load i32 addrspace(2)* @counter, !gla.uniform !10
  %3 = call i32 @llvm.gla.atomicCounterDecrement(i32 %2), !gla.precision !15
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %mainBody
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: alwaysinline
define internal fastcc i32 @"func(au1;"(i32*) #0 {
entry:
  %1 = load i32* %0
  %2 = call i32 @llvm.gla.atomicCounterIncrement(i32 %1), !gla.precision !15
  ret i32 %2

post-return:                                      ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc void @"atoms("() #0 {
entry:
  %origu = alloca i32
  %origi = alloca i32
  %origi1 = call i32 @llvm.gla.atomicAdd.p4i32(i32 addrspace(4)* @atomi, i32 3), !gla.precision !15
  store i32 %origi1, i32* %origi
  %0 = load i32 addrspace(2)* @value, !gla.uniform !3
  %origu2 = call i32 @llvm.gla.atomicAnd.p4i32(i32 addrspace(4)* @atomu, i32 %0), !gla.precision !15
  store i32 %origu2, i32* %origu
  %origu3 = call i32 @llvm.gla.atomicOr.p4i32(i32 addrspace(4)* @atomu, i32 7), !gla.precision !15
  store i32 %origu3, i32* %origu
  %origu4 = call i32 @llvm.gla.atomicXor.p4i32(i32 addrspace(4)* @atomu, i32 7), !gla.precision !15
  store i32 %origu4, i32* %origu
  %1 = load i32 addrspace(2)* @value, !gla.uniform !3
  %origu5 = call i32 @llvm.gla.uAtomicMin.p4i32(i32 addrspace(4)* @atomu, i32 %1), !gla.precision !15
  store i32 %origu5, i32* %origu
  %origi6 = call i32 @llvm.gla.sAtomicMax.p4i32(i32 addrspace(4)* @atomi, i32 7), !gla.precision !15
  store i32 %origi6, i32* %origi
  %2 = load i32* %origi
  %origi7 = call i32 @llvm.gla.atomicExchange.p4i32(i32 addrspace(4)* @atomi, i32 %2), !gla.precision !15
  store i32 %origi7, i32* %origi
  %3 = load i32 addrspace(2)* @value, !gla.uniform !3
  %origu8 = call i32 @llvm.gla.atomicCompExchange.p4i32(i32 addrspace(4)* @atomu, i32 10, i32 %3), !gla.precision !15
  store i32 %origu8, i32* %origu
  %misc2a = call i32 @llvm.gla.atomicAdd.p3i32(i32 addrspace(3)* getelementptr inbounds (%bname addrspace(3)* @binst, i32 0, i32 1), i32 1), !gla.precision !15, !gla.uniform !5
  %misc2a9 = call i32 @llvm.gla.atomicXor.p3i32(i32 addrspace(3)* getelementptr inbounds (%bname addrspace(3)* @binst, i32 0, i32 0, i32 1), i32 5), !gla.precision !15, !gla.uniform !5
  ret void
}

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicCounterIncrement(i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicAdd.p4i32(i32 addrspace(4)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicAnd.p4i32(i32 addrspace(4)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicOr.p4i32(i32 addrspace(4)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicXor.p4i32(i32 addrspace(4)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.uAtomicMin.p4i32(i32 addrspace(4)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.sAtomicMax.p4i32(i32 addrspace(4)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicExchange.p4i32(i32 addrspace(4)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicCompExchange.p4i32(i32 addrspace(4)*, i32, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicAdd.p3i32(i32 addrspace(3)*, i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicXor.p3i32(i32 addrspace(3)*, i32) #1

; Function Attrs: nounwind
declare void @llvm.gla.memoryBarrierAtomicCounter() #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicCounterLoad(i32) #1

; Function Attrs: nounwind
declare i32 @llvm.gla.atomicCounterDecrement(i32) #1

attributes #0 = { alwaysinline }
attributes #1 = { nounwind }

!gla.localSize = !{!0}
!gla.shared = !{!1, !2}
!gla.uniforms = !{!3, !5, !10, !12}
!gla.entrypoint = !{!14}

!0 = !{i32 1, i32 1, i32 1}
!1 = !{i32 addrspace(4)* @atomi}
!2 = !{i32 addrspace(4)* @atomu}
!3 = !{!"value", i32 12, i32* @value_typeProxy, !4}
!4 = !{i32 1, i32 3, i32 1024, null, i32 -1, i32 0, i32 -1, i32 0, i32 -1}
!5 = !{!"binst", i32 14, %bname* @binst_typeProxy, !6, !7}
!6 = !{i32 6, i32 0, i32 1024, null, i32 -1, i32 0, i32 -1, i32 0, i32 -1}
!7 = !{!"bname", !6, !"v", !8, !"s", !8}
!8 = !{!"", !9}
!9 = !{i32 0, i32 3, i32 1024, null, i32 -1, i32 0, i32 -1, i32 0, i32 -1}
!10 = !{!"counter", i32 12, i32* @counter_typeProxy, !11}
!11 = !{i32 10, i32 3, i32 1024, null, i32 -1, i32 0, i32 0, i32 0, i32 0}
!12 = !{!"countArr", i32 12, [4 x i32]* @countArr_typeProxy, !13}
!13 = !{i32 10, i32 3, i32 1024, null, i32 -1, i32 0, i32 0, i32 0, i32 4}
!14 = !{!"main", i32 15}
!15 = !{i32 3}
